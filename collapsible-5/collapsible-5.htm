<!DOCTYPE html>
<html lang="en-US"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="template-info" content="empty.htm 2021-08-23 usp" />
<meta name="author" content="usp" />
<meta name="creation-date" content="2021-07-01" />
<meta name="editor" content="usp" />
<meta name="change-date" content="2021-07-02" />
<meta name="version" content="2" />
<meta name="categories" content="Music > Guitar > Fretboard" />
<meta name="tags" content="Music, scale, interval, major, guitar, fretboard" />
<meta name="description" content="The C major scale, notes and intervals" />
<title>Music - The C Major Scale</title>

<link rel="stylesheet" href="/inc/page.css" />

</head><body><div id="page-header"></div><div id="main-toolbar"><div id="content">

<h1>Collabsible Blocks 5</h1>

<p>This version of collapsible block also builds on the max-height style attibute of the collapsible block. Setting it to a value of 0px does not affect its scroll-height value, even it the page layout changes. So we can always expand a collapsed block to its full height (nearly) without problems.</p>

<p>Using a transition on the max-height style requires numerical values, so we cannot immediately set <tt>maxHeight="none"</tt> to expand a collapsed block. Therefore a transition end event handler is registered with a collapsible block to set maxHeight to none, which is required to account for potential layout changes.</p>

<p>The goal of this version is to combine collapsible trees and collabsible blocks into one core logic. The structures differ somewhat. A collapsible block expects a controller element with a <tt>cbc</tt> attribute, followed immediatedly by the collabsible block. A tree structure is an unordered list (UL) element with a <tt>collapsible</tt> attribute. List items (LI) are automatically identified as controllers if they have a nested list child element (LI>UL), their <tt>cbc</tt> attribute is generated by a script. The nested UL element is the collapsible block. However, the principle of collapsing and expanding the blocks by manipulating the max-height attribute is the same.</p>

<p>To simplify the CSS code, an LI element with no nested UL also gets a <tt>cbc</tt> attribute, but with a value of "static", which means that there is no collapsible block, so these elements get a different list style image (a dot instead of plus and minus).</p>

<p>Let's first have a look at the collapsbible block structures, with a cbc controller element, followed by the collapbsible block element. If an element is decorated with a <tt>cbc</tt> attribute, the following CSS rule generates an anomymous content element:</p>

<pre>
[cbc]:before {
    content: "";
    display: inline-block;
    height: 0.8em;
    width: 30px;
    background-size: contain;
    background-repeat: no-repeat;
	background-position-x : center ;
	margin-bottom: -0.2ex ;
	}
</pre>

<p>It is styled as inline-block with a fixed width and a font-size dependent height. This element is designed to have a background image that reflects the controller state, either "collapsed", or "expanded". The margin bottom is used to tweak the vertical position of the icon so that it is perfectly aligned with the text content.</p>

<p>The background image is defined by the value of the cbc attribute:</p>

<pre>[cbc="expanded"]:before {
    background-image: url("orange-minus.svg") !important;
	}
[cbc="collapsed"]:before {
    background-image: url("orange-plus.svg") !important;
	}
</pre>

<p>List items in collapsible trees have no list style icon, and the left-side padding is somewhat reduced:</p>

<pre>
ul.collapsible {
	padding-left : 25px ;
	}

ul.collapsible li {
	list-style-type : none ;
	}
</pre>

<p>Nested list elements must clip their content, so we must set overflow to hidden:</p>

<pre>
ul.collapsible ul {
	overflow : hidden ;
	transition : max-height 0.3s linear;
	padding-left : 20px;
	}
</pre>

<p>By default, list items in collapsible trees have a dot icon in front to make all items look similar. This is different from linear collapsible block structures, where there is no concept of non-expandable blocks.</p>

<pre>
ul.collapsible li:before {
    margin-left: -20px;
    background-image: url("/inc/collapsible/orange-dot.svg");
}
</pre>

<p>The CSS is supported by some scripting. When the page content is completely loaded, the initPage function must be called:</p>

<pre>initPage( document );</pre>

<p>This is a two-part function. The first part decorates the LI elements in collapsible tree structures with cbc attributes, the second part configures the associated blocks and registers the necessary event handlers.</p>

<p>Here is the first part:</p>

<pre>
function initPage ( container ) {
	<cc>// Decorate controller elements in collapsible trees.</cc>
	let collapsibles = container.querySelectorAll( ".collapsible" );
	for ( let i = 0 ; i < collapsibles.length ; i ++ ) {
		let collapsible = collapsibles[ i ];
		let blocks = collapsible.querySelectorAll( "UL" );
		for ( let j = 0 ; j < blocks.length ; j ++ ) {
			let block = blocks[ j ];
			// Set a reference from controller to associated collapsible block.
			let controller = block.parentNode;
			if ( ! controller.hasAttribute( "cbc" )) controller.setAttribute( "cbc", "collapsed" );
			if ( ! controller.synesis ) controller.synesis = { } ;
			controller.synesis.collapsibleBlock = block ;
			}
		let statics = collapsible.querySelectorAll( "LI:not([cbc])" );
		for ( let j = 0 ; j < statics.length ; j ++ ) statics[ j ].setAttribute( "cbc", "static" );
		}
</pre>

<p>The code collects the collapsible tree elements and identifies collapsible block (UL) elements inside. Their parent LI element is a controller. The code makes sure that it has a proper <tt>cbc</tt> attribute. Note that the page author can supply a cbc attribute and override the default value ("collapsed") with "expanded".</p>

<p>To make the event handler simpler, the controller gets a reference to the associated collapsible block element.</p>

<p>The last instructions ensure that the remaining LI elements are decorated with a <tt>cbc="static"</tt> attribute to ensure that CSS provides a list style image in front of them.</p>

<p>The second part treats all collapsible blocks, not only the ones in collapsible trees. The code collects all block controllers and ensures that they have a properly configured cbc attribute (the page author may specify a cbc attribute without value, which defaults to "collapsed"). Controllers with a cbc attribute value of "static" are special in that they are excluded from the following processing steps.</p>

<p>Then a reference to the associated block element is stored if not already present. Also, these blocks are styled to hide overflowing content and make a smooth transition on the max-height style attribute. Setting these style rules inline, i. e. directly on the block elements simplifies CSS rules to a great deal.</p>

<pre>
	<cc>// Prepare collapsible blocks and their controllers</cc>
	let controllers = container.querySelectorAll( "[cbc]" );
	for ( let i = 0 ; i < controllers.length ; i ++ ) {
		let controller = controllers[ i ];
		if ( controller.getAttribute( "cbc" ) === "" ) controller.setAttribute( "cbc", "collapsed" );
		else if ( controller.getAttribute( "cbc" ) === "static" ) continue;
		<cc>// Set a reference from controller to collapsible block if not done above.</cc>
		controller.synesis = controller.synesis || { } ;
		let block =  controller.synesis.collapsibleBlock;
		if ( ! block ) {
			block = controller.synesis.collapsibleBlock = controller.nextElementSibling ;
			<cc>// It is easier to set the block styles here than in CSS.</cc>
			block.style.transition = "max-height 0.3s linear" ;
			block.style.overflow = "hidden" ;
			}
		<cc>// Initialize controller state and add event handlers.</cc>
		if ( controller.getAttribute( "cbc" ) === "collapsed" ) block.style.maxHeight = "0px" ;
		controller.addEventListener( "click" , clickHandler );
		block.addEventListener( "transitionend", transitionEndHandler );
		} }
</pre>

<p>The last instructions set the max-height style value and register the necessary event handlers on controller and block elements.</p>

<p>The click event handler determines the current controller state. To expand a block, max-height is changed from zero to scroll-height. To collapse a block, a two-step approach needs to be taken. First, the max-height attribute is set to the current scroll-height value. To make sure that the change makes it into the DOM, the second step is made in the next animation frame, i. e. in a separate event processing loop of the JavaScript engine, where the max-height is set to 0px:</p>

<pre>
function clickHandler ( evt ) { 
	let block = evt.target.synesis.collapsibleBlock ;
	if ( evt.target.getAttribute( "cbc" ) === "collapsed" ) {
		block.style.maxHeight = block.scrollHeight + "px";
		evt.target.setAttribute( "cbc", "expanded" );
		}
	else if ( evt.target.getAttribute( "cbc" ) === "expanded" ) {
		block.style.maxHeight = block.scrollHeight + "px" ;
		evt.target.setAttribute( "cbc", "collapsed" );
		window.requestAnimationFrame( function ( ) { 
			block.style.maxHeight = "0px" ;
		} ) ; } 
	evt.preventDefault();
	evt.stopPropagation( );
	}
</pre>

<p>The code is completed with the transition end event handler, where the max-height limitation on an expanded block is removed (maxHeight="none"):</p>

<pre>
function transitionEndHandler ( evt ) { 
	if ( evt.target.style.maxHeight !== "0px" ) evt.target.style.maxHeight = "none" ;
	evt.preventDefault();
	evt.stopPropagation( );
	} 
</pre>

<p>The rest of the code is support for special applications, for instance, the expandPath function:</p>

<pre>

export function expandPath( id ) {
	let e = document.getElementById( id );
	if ( ! e ) return;
</pre>

<p>This is a test form.</p>

<ul class="collapsible">
<li cbc="collapsed"><a href="about:blank">TEST 0</a>
	<ul>
	<li>Test 1</li>
	<li>Test 2
		<ul>
		<li>Test 5</li>
		<li>Test 6
			<ul>
			<li>Test 5</li>
			<li>Test 6</li>
			<li>Test 7</li>
			</ul></li>
		<li>Test 7</li>
		</ul></li>
	<li>Test 3</li>
	</ul></li>
<li cbc="collapsed">Test 4
	<ul>
	<li>Test 5</li>
	<li>Test 6</li>
	<li>Test 7</li>
	</ul></li>
<li>MMXX</li>
</ul>

<h2 cbc>This is a test header</h2><div>

<p>This is in a collapsible block.</p>

<h3 cbc>This is a nested header</h3><div>
<p>This is in a collapsible block.</p>
<h4 cbc>This is a nested header</h4><div>
<p>This is in a collapsible block.</p>
<h5 cbc>This is a nested header</h5><div>
<p>This is in a collapsible block.</p>
</div>
</div>
</div>

</div>

<p>This is the next paragraph.</p>

<p>The goal is to combine collapsible trees and collapsible block structures and provide identical behavior. Collapsible trees are nested lists with a root element class "collabsible". The controllers are list item (LI) elements which contain a nested collapsible list (UL) element. Collapsible block structures are controller elements with a <tt>cbc</tt> attribute, followed by the collapsible block element.</p>

<h2>Notes</h2><div>

<ol>
<li>The goal is to have the list style image automatically scale with the line height.</li>

<li>No width and height but proper viewbox in SVG causes the list icon to size with the font, but the image is way too small (see <a href="https://stackoverflow.com/questions/7775594/css-list-style-image-size">Jeremy's comments</a> an Stackoverflow.)</li>
<li>Giving height and width attributes determine the icon size, but the icon is not scaled with the font size or line height.</li>
<li>The viewbox in SVG causes the icon to be scaled according to width and height attributes.</li>
<li>If the viewbox attribute in SVG is omitted, the coordinates of the drawing instructions are note scaled. In other words, the drawing coordinates determine the size of the image.</li>
<li>The vertical position can be controlled with a negative margin bottom. A value of 0.2ex seems to be right to scale with the font size.</li>
</ol>
</div>

<script src="/inc/collapsible/collapsible-5.js" type="module" ></script>

<xxscript type="module">
initPage( document );

function initPage ( container ) {
	// Decorate controller elements in collapsible trees.
	let collapsibles = container.querySelectorAll( ".collapsible" );
	for ( let i = 0 ; i < collapsibles.length ; i ++ ) {
		let collapsible = collapsibles[ i ];
		let blocks = collapsible.querySelectorAll( "UL" );
		for ( let j = 0 ; j < blocks.length ; j ++ ) {
			let block = blocks[ j ];
			// Set a reference from controller to associated collapsible block.
			let controller = block.parentNode;
			if ( ! controller.hasAttribute( "cbc" )) controller.setAttribute( "cbc", "collapsed" );
			if ( ! controller.synesis ) controller.synesis = { } ;
			controller.synesis.collapsibleBlock = block ;
			}
		let statics = collapsible.querySelectorAll( "LI:not([cbc])" );
		for ( let j = 0 ; j < statics.length ; j ++ ) statics[ j ].setAttribute( "cbc", "static" );
		}

	// Prepare collapsible blocks and their controllers
	let controllers = container.querySelectorAll( "[cbc]" );
	for ( let i = 0 ; i < controllers.length ; i ++ ) {
		let controller = controllers[ i ];
		if ( controller.getAttribute( "cbc" ) === "" ) controller.setAttribute( "cbc", "collapsed" );
		else if ( controller.getAttribute( "cbc" ) === "static" ) continue;
		// Set a reference from controller to collapsible block if not done above.
		controller.synesis = controller.synesis || { } ;
		let block =  controller.synesis.collapsibleBlock;
		if ( ! block ) {
			block = controller.synesis.collapsibleBlock = controller.nextElementSibling ;
			// It is easier to set the block styles here than in CSS.
			block.style.transition = "max-height 0.3s linear" ;
			block.style.overflow = "hidden" ;
			}
		// Initialize controller state and add event handlers.
		if ( controller.getAttribute( "cbc" ) === "collapsed" ) block.style.maxHeight = "0px" ;
		controller.addEventListener( "click" , clickHandler );
		block.addEventListener( "transitionend", transitionEndHandler );
		} }

function clickHandler ( evt ) { 
	// if ( evt.x > 30 ) return;
	let block = evt.target.synesis.collapsibleBlock ;
	if ( evt.target.getAttribute( "cbc" ) === "collapsed" ) {
		block.style.maxHeight = block.scrollHeight + "px";
		evt.target.setAttribute( "cbc", "expanded" );
		}
	else if ( evt.target.getAttribute( "cbc" ) === "expanded" ) {
		block.style.maxHeight = block.scrollHeight + "px" ;
		evt.target.setAttribute( "cbc", "collapsed" );
		window.requestAnimationFrame( function ( ) { 
			block.style.maxHeight = "0px" ;
		} ) ; } 
	evt.preventDefault();
	evt.stopPropagation( );
	}

function transitionEndHandler ( evt ) { 
	if ( evt.target.style.maxHeight !== "0px" ) evt.target.style.maxHeight = "none" ;
	evt.preventDefault();
	evt.stopPropagation( );
	} 

</xxscript>

</div><script type="module" src="/inc/page.js"></script></body></html>